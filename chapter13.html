<!DOCTYPE html><html><head><meta charset="utf-8"><title>Chapter 13: </title><link rel="stylesheet" href="css/main.css"><script src="js/jquery-2.1.1.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
  tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]}
});</script><script src="js/MathJax/MathJax.js"></script><script src="js/parser.js"></script><script type="text/javascript">function texify(lojban) {
  return parser.parse(lojban);
}</script></head><body><div class="main"><div class="auto dnav"><div class="fleft"><a href="chapter12.html">prev</a><div class="small">Quantification, lol</div></div></div><div class="quote">Everyone who's thought about it says {ro} doesn't import. Sadly, we don't know from that whether anyone has thought about it.</div><div class="qauthor">xalbo</div><div class="title">Chapter 13: A logical perspective</div><hr class="grad space"><p>Thus far, we have already gone over the basics of negation.  In the previous chapter, we have gone over the effects of inner and outer quantifiers on gadri.  However, from a logical perspective, we have taken a very simplistic view of what they <span class="i">are</span>.</p><p>When I say <span class="l">re lo ci gerku cu broda</span> I describe that <span class="i">"Two of the three dogs broda."</span></p><p>However, what am I truly describing when I say that?  Without defining such a statement in mathematical terms it hardly has more than a tenuous definition, no better than the English equivalent.  Lojban is designed to rectify this.</p><p>To properly demonstrate the specific meaning of this statement, existential quantifiers will be introduced.  The most simple usage of existential quantifiers in Lojban is simply plain <span class="l">da</span> without a quantifier before it.  We also have <span class="l">de</span> and <span class="l">di</span> so we can use more quantifiers.</p><aside>If you're familiar with quantification in logic, this chapter will probably be really easy for you.  AKA,  <span class="l">su'o da broda</span> means $ \exists x \left ( broda(x) \right ) $ and <span class="l">ro da broda</span> means $ \forall x \left ( broda(x) \right ) $.  <span class="l">da broda ro de</span> means $ \exists x \forall y \left ( broda(x,y) \right ) $</aside><p><span class="l">da</span>, by default, has the quantifier <span class="l">su'o</span> unless it is replaced by putting another quantifier there.  This means that typically, to say <span class="l">su'o da</span> in casual speech, one usually just says <span class="l">da</span>.  The most rudimentary, single-word definition of <span class="l">su'o da</span> is <span class="i">"something"</span>.  However, the mechanisms behind it are more complex than that.  More accurately, it can be expressed as <span class="i">"there exists something"</span>.  <span class="l">su'o da gerku</span> means "There exists something such that it is a dog."  As long as there is at least one thing in the entire universe that happens to be a dog, <span class="l">su'o da gerku</span> holds true.</p><p>You can quantify <span class="l">da</span> in other ways, as well.  <span class="l">ro da</span> means <span class="i">"everything"</span>, or more specifically, <span class="i">"for all"</span>.  In contrast, <span class="l">ci da</span> means <span class="l">"exactly three things"</span>, no more and no less.</p><p>Some example true statements are <span class="i">"There exists an even prime number"</span> (the number 2), <span class="i">"There exists an odd prime number"</span> (all other primes), and <span class="i">"For all integers x, 2*x is even"</span>.</p><p>To make clear how these statements work, we will observe the effects of these quantifiers from the perspective of a computer scientist. First we will focus on the effects of existential quantification (e.g. <span class="l">su'o da</span>) and universal quantification (e.g. <span class="l">ro da</span>).</p><div id="tabs"><div title="Haskell" class="tab"><p>Demonstrating quantifiers is easy in Haskell.  In our demonstration we will be using foldr and boolean operators to evaluate whether math statements that use quantifiers are true.</p><p>Consider that in Haskell, <span class="code">or = foldr (||) False</span>, and <span class="code">and = foldr (&&) True</span>.  This means that, if you have a list of booleans, "a single bad apple spoils the bunch" in that if even a single element in the list is true, <span class="code">or</span> returns true for the entire list.  Similarly, if even a single element is false with <span class="code">and</span> it returns false for the entire list.</p><!--p #[span.code or] is to #[span.l da] as #[span.code and] is to #[span.l ro da].  #[span.l da gerku] is true if there's even a single thing in the entire universe which is a dog, and #[span.l ro da gerku] is only true if every single thing in the entire universe is dogs.  #[span.l ro da gerku] can be proven false without a second thought, since plenty of things all around you are not dogs.  The #[span.code foldr] stops the moment it finds a single thing that isn't a dog, thanks to the lazy nature of Haskell.--><p>A Haskellization of <span class="l">su'o da poi prenu cu se kanla lo zirpu</span> ("There exists somebody with purple eyes.") would be <span class="code">or [purple x | x <- people]</span>, where <span class="code">people</span> is a list of every person on Earth and <span class="code">purple</span> is a function that returns a Bool as to whether a given person has purple eyes.  Similarly, <span class="l">ro da poi prenu cu se kanla lo zirpu</span> ("All people have purple eyes.") would be <span class="code">and [purple x | x <- people]</span>.  Both of these statements would be false, of course.</p></div><div title="C++" class="tab"></div><div title="Python" class="tab"></div></div><p>A consequence of this is that it is easy to prove, for example, there <span class="i">exists</span> a person with non-purple eyes (a common feature) and that not all people have purple eyes, but hard to prove that <span class="i">all</span> people have non-purple eyes or that there exists someone who does have purple eyes.  The first two are easy because it only takes one instance to confirm the statement, but the second two are hard because you have to either check every single person in the world's eyes, or get smart about the way you prove the statement.  (AKA, you demonstrate it's biologically impossible for people to have naturally purple eyes, for example.)</p><p>To negate a statement where the quantifier is <span class="i">inside</span> what's being negated, you <span class="b">invert (negate) the quantifier and then negate the claim inside</span>.  The negation of <span class="l">su'o</span> is <span class="l">ro</span> and vice versa.  So the negation of "for all" is "there exists"   Think about this.  If it is false that all people have purple eyes, then there must exist at least one person who does not have purple eyes, right?  These two statements are the same!</p><p>Consider the scope of negation in these two (equivalent) statements.  We're going to use English notation that includes parentheses to show what sections of the sentence are in the negation's scope.  The former can be written as "([not] all people have purple eyes)", and the latter can be written as "there exists someone who ([not] has purple eyes)".  As you can see, the quantifier "all" has been inverted (negated) to "exists" and the claim "has purple eyes" has been negated.</p><aside>Have you noticed the connection to De Morgan's laws yet?  The system of negation I'm teaching is really just a different way of looking at De Morgan's laws.  These two sentences' Haskell translations are <span class="code">(not . and) [purple x | x <- people]</span> and <span class="code">or [(not . purple) x | x <- people]</span>, respectively.  Do you see it's one giant rendition of the same concept?</aside><p>Lojban's <span class="l">naku</span> is similar to <span class="l">na</span>, but it acts as a term rather than a selbri operator. It functions much like opening one of these "negation scopes".  <span class="l">naku ro da poi prenu cu se kanla lo zirpu</span> = "([not] all people have purple eyes)", and <span class="l">da poi prenu ku'o naku se kanla lo zirpu</span> = "there exists someone who ([not] has purple eyes)".  Again, both of these statements are equal.</p><p>There are other implications of this behavior of <span class="l">naku</span>.  <span class="l">naku naku broda</span> as you know is equivalent to <span class="l">broda</span>, but in addition, <span class="l">naku su'o da naku broda</span> is equivalent to <span class="l">ro da broda</span>.  Consider the "negation scopes" of this sentence: "([not] there exists something that does ([not] broda))".  Multiple <span class="l">naku</span> simply negate everything to the right of them.  Doesn't it make sense that "It is false that there exists something which doesn't broda" is equivalent to "Everything brodas"?  Similarly, "It is false that all things don't broda" is equivalent to "There exists something which brodas".  (Do note that <span class="l">naku broda</span> is the same as <span class="l">broda naku</span>; there's still an odd number of negations.  "negation scope" only affects terms of a bridi.)</p><aside>In Haskell, <span class="code">and []</span> is True, of course. (<span class="code">or []</span> is False) This theme of logical and being "shut off" by an instance of false is one of the reasons why <span class="l">ro</span> does not have something called "existential import".  Not having existential import means <span class="l">ro da poi broda cu gerku</span> is true even if nothing actually brodas.  Our meaning of "all" is "100%" rather than "100% and at least one".</aside><p>Now we will investigate the effects of using multiple quantifiers in the same sentence.  Remember that we can also use <span class="l">de</span> and <span class="l">di</span> as additional quantifiers.  Consider them like <span class="i">x</span>, <span class="i">y</span>, and <span class="i">z</span>.  Which one you choose doesn't matter, but in quantification, the order you put them in matters.  <span class="l">ro da poi prenu cu broda su'o de</span> is different from <span class="l">su'o da poi prenu cu broda ro de</span>.  To help understand why and how these sentences differ, we will introduce the concept of the prenex.</p><p>When a quantified variable appears for the first time in a bridi, it could be said that it "moves to the prenex".  The prenex is something you can optionally state at the start of a bridi.  To end the prenex, you say <span class="l">zo'u</span>.  Grammatically, the prenex is a sequence of terms followed by <span class="l">zo'u</span>.  Some examples of this behavior of "moving to the prenex" are <span class="l">da gerku</span> = <span class="l">su'o da zo'u da gerku</span> and <span class="l">ro da gerku</span> = <span class="l">ro da zo'u da gerku</span></p><p>When you have more than one quantifer, they move to the prenex in order like so: <span class="l">ro da broda de</span> = <span class="l">ro da su'o de zo'u da broda de</span> and <span class="l">da broda ro de</span> = <span class="l">su'o da ro de zo'u da broda de</span></p><p>We can also use quantifiers as a mechanic to state quantifiers in a diffent order than they were grammatically introduced: <span class="l">su'o da broda ro de</span> = <span class="l">su'o da ro de zo'u de se broda da</span></p><aside>Remember <span class="l">da</span>/<span class="l">de</span>/<span class="l">di</span> are like <span class="i">x</span>, <span class="i">y</span>, and <span class="i">z</span>.  You could swap <span class="l">da</span> and <span class="l">de</span> in any sentence and it would still have the same meaning.</aside><p>Now what do these sentences mean?  <span class="l">ro da broda su'o de</span> translates to "Everything brodas something" and <span class="l">su'o da broda rode</span> translates to "Something brodas everything".  However, the English translation falls short, because you would think those two sentences are simply inverted when they in fact have entirely different meanings.   To understand this, we will show these statements using mathematical logic notation.  It sounds hard, but it's actually literally a one to one conversion with the concept of the prenex we just introduced.</p><p>We're going to use two new symbols, which represent things we've already learned.  $\exists$ means "there exists".  $\forall$ means "for all".  Sounds familiar, right?  In fact, the translation is easy: <span class="l">su'o da zo'u da broda</span> = $ \exists x \left ( broda(x) \right ) $, and  <span class="l">ro da zo'u da broda</span> = $ \forall x \left ( broda(x) \right ) $.  In the first statement, we're using the special symbol in $ \exists x $ to quantify that <span class="i">there exists an x</span> such that $ broda(x) $ (the thing inside the parentheses) is true.  In the second statement, we're using the special symbol in $ \forall x $ to quantify that <span class="i">for every possible x</span>, $ broda(x) $ is always true.</p><p>Finally, we approach the answer you've been waiting for.  Now what happens when we use multiple quantifiers, such as in <span class="l">ro da su'o de zo'u da broda de</span>?  Well, that translates to $ \forall x \exists y \left ( broda(x,y) \right ) $, which is just shorthand notation for $ \forall x \left ( \exists y \left ( broda(x,y) \right ) \right ) $.  This in English translates to "For every possible thing x, there's at least one thing y such that x brodas y", in the sense that $y$ can be completely different for each $x$.</p><aside>Notice how the $\exists$-claim is "one level deep" inside the $\forall$-claim.  You could look at this very similarly to the way you look at multiple levels of iteration, or multiple levels of list comprehensions in Haskell/Python.  A simple example of the latter is <span class="code">[(x,y) | x <- [1..5], y <- [1..5]]</span>, but again, we can write Lojban in Haskell: <span class="l">ro da brode su'o de</span> = $ \forall x \exists y \left ( broda(x,y) \right ) $ = <span class="code">and [ or [broda x y | y <- everything] | x <- everything]</span></aside><p>To assist comprehension, here are some example sentences:</p><table style="font-size:75%"><tr><td><span class="l">su'o da broda su'o de</span></td><td><span class="l">su'o da su'o de zo'u da broda de</span></td><td>$ \exists x \exists y \left ( broda(x,y) \right ) $</td><td>"Something brodas something"</td></tr><tr><td><span class="l">su'o da broda ro de</span></td><td><span class="l">su'o da ro de zo'u da broda de</span></td><td>$ \exists x \forall y \left ( broda(x,y) \right ) $</td><td>"There exists something that brodas all things" *</td></tr><tr><td><span class="l">ro da broda su'o de</span></td><td><span class="l">ro da su'o de zo'u da broda de</span></td><td>$ \forall x \exists y \left ( broda(x,y) \right ) $</td><td>"For all things, there's something that it brodas" **</td></tr><tr><td><span class="l">ro da broda ro de</span></td><td><span class="l">ro da ro de zo'u da broda de</span></td><td>$ \forall x \forall y \left ( broda(x,y) \right ) $</td><td>"Everything brodas everything"</td></tr></table><p style="font-size:60%;line-height:1;">* as in, a single thing $x$ exists where any $y$ can be paired with it and "$x$ broda $y$" will be true.<br>** as in, for any $x$, there will always be at least one $y$, possibly a different $y$ for each one, that you can pair with it so "$x$ broda $y$" will be true.</p><p>The last thing to know is how negation affects multiple quantification.  To negate a statement in math, we use the $\lnot$ symbol.  $\lnot broda()$ is the same as <span class="l">na broda</span>/<span class="l">naku broda</span>.</p><p>There is a difference between <span class="l">su'o da naku broda</span> and <span class="l">naku su'o da broda</span>.  The former is $\exists x \left ( \lnot broda(x) \right )$ ("there exists an x that does not broda") and the latter is $\lnot \exists x \left ( broda(x) \right)$ ("it is false that there exists an x that brodas").</p><p>To move negation from outside quantification to inside the claim being quantified, you <span class="b">invert (negate) the quantifier and then negate the claim inside</span>.  Sounds familiar, right?  I bolded both times I said that just for you.  We remember that the inverse of "there exists" is "for all" and vice versa, so $\lnot \exists x \left ( broda(x) \right) \equiv \forall x \left ( \lnot broda(x) \right)$ (the triple-equals expresses logical equivalence- that is, that they state the exact same thing).</p><p>The way to negate with multiple quantifiers is just an extension of this concept.  $\lnot \exists x \left ( P(x) \right) \equiv \forall x \left ( \lnot P(x) \right )$ for any proposition $P(x)$.  $P(x)$ could be $broda(x)$, if we want.  But what if $P(x)$ was $\forall y \left ( broda(x,y) \right)$?  Then it must follow that $\lnot \exists x \left ( \forall y \left ( broda(x,y) \right) \right) \equiv \forall x \left ( \lnot \forall y \left ( broda(x,y) \right) \right )$.  If we can do this once, we can do this twice, so $\forall x \left ( \lnot \forall y \left ( broda(x,y) \right) \right ) \equiv \forall x \left ( \exists y \left ( \lnot broda(x,y) \right) \right ) \equiv \forall x \exists y \left ( \lnot broda(x,y) \right)$.  Effectively, you are "carrying" the negation deeper into the expression while inverting quantifiers to maintain equivalence.</p><p>In order to negate quantifiers when you have a prenex, fittingly, the negation has to be in the middle of the prenex, similar to mathematical expressions.  Here is another table of examples to demonstrate regularity of behavior:</p><table style="font-size:75%"><tr><td><span class="l">naku da broda de</span></td><td><span class="l">naku da de zo'u da broda de</span></td><td>$ \lnot \exists x \exists y \left ( broda(x,y) \right ) $ <br> $\equiv \forall x \forall y \left ( \lnot broda(x,y) \right )$</td><td>"Nothing brodas anything"</td></tr><tr><td><span class="l">da naku broda ro de</span></td><td><span class="l">da naku ro de zo'u da broda de</span></td><td>$ \exists x \lnot \forall y \left ( broda(x,y) \right ) $ <br> $\equiv \exists x \exists y \left ( \lnot broda(x,y) \right )$</td><td>"Something doesn't broda another thing"</td></tr><tr><td><span class="l">ro da broda ro de naku</span></td><td><span class="l">da ro de naku zo'u da broda de</span><br><span>or </span><span class="l">da ro de zo'u naku da broda de</span><br><span>or </span><span class="l">da ro de zo'u da broda de naku</span><span> *</span></td><td>$\exists x \forall y \left ( \lnot broda(x,y) \right )$</td><td>"Something doesn't broda anything"</td></tr><tr><td><span class="l">naku da naku broda de</span></td><td><span class="l">naku da naku de zo'u da broda de</span></td><td>$ \lnot \exists x \lnot \exists y \left ( broda(x,y) \right ) $ <br> $\equiv \forall x \lnot \lnot \exists y \left ( broda(x,y) \right )$ <br> $\equiv \forall x \exists y \left ( broda(x,y) \right )$</td><td>"Everything brodas something" or, more true to the original wording "there doesn't exist something which <span class="i">doesn't</span> broda something" **</td></tr></table><p style="font-size:60%;line-height:1;">*: Notice how once the actual quantifiers are in the prenex, the position of <span class="l">naku</span> in the main bridi doesn't matter.  It just negates the claim. <br> **: Look! We "carry" the negation in, and it creates a double negation later which eliminates itself.  We actually saw this behavior earlier when we were looking at this type of behavior as "negation scope".</p><p>We have gone over logical quantification and negation's effects on it; now, we will cover the final question asked in the beginning of this chapter:  What does <span class="l">re lo ci gerku cu broda</span> mean?  As it turns out, "outer" quantification, the <span class="l">re</span>, is no different from quantification of <span class="l">da</span>.  The inner quantification, the <span class="l">ci</span>, however, is a special concept specific to gadri.  Considering that <span class="l">re</span> is just a quantification of <span class="l">lo ci gerku</span>, we must understand how these two parts function individually.  <span class="l">lo ci gerku cu broda</span> on its own, means "3 dogs broda", with no implications regarding whether it is distributive or not, as you already know.</p><p>However, what does <span class="l">re</span> do?  First, we will look at <span class="l">re broda</span>.  <span class="l">re broda</span> is equivalent to <span class="l">re da poi broda</span> (assuming there's no other quantifiers to interfere).  Similarly, <span class="l">mu ko'a</span> where <span class="l">ko'a</span> is equivalent to any arbitrary sumti is the same as <span class="l">mu da poi ka'e me ko'a</span>.  <span class="l">me</span> is the word for subset (the set of primes is a subset of the set of integers) and <span class="l">ka'e</span> is the word for "can be true" (not necessarily is).  So <span class="l">ro ko'a</span> means every single <span class="i">individual</span> which is a member of <span class="l">ko'a</span>!  This is why <span class="l">ro lo mu bakni</span> means "each/all of the 5 cows individually" and <span class="l">re lo ci gerku</span> means "2 of the 3 dogs individually".  This also means that <span class="l">naku</span> inverts outer quantifiers but <span class="b">not</span> inner quantifiers.</p><div class="auto dnav"><div class="fleft"><a href="chapter12.html">prev</a><div class="small">Quantification, lol</div></div></div></div></body></html>